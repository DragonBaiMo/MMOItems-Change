diff --git a/MMOItems-API/src/main/java/net/Indyuce/mmoitems/api/interaction/util/CustomDurabilityItem.java b/MMOItems-API/src/main/java/net/Indyuce/mmoitems/api/interaction/util/CustomDurabilityItem.java
index d47dda8fc..72b058ea8 100644
--- a/MMOItems-API/src/main/java/net/Indyuce/mmoitems/api/interaction/util/CustomDurabilityItem.java
+++ b/MMOItems-API/src/main/java/net/Indyuce/mmoitems/api/interaction/util/CustomDurabilityItem.java
@@ -62,16 +62,21 @@ public class CustomDurabilityItem extends DurabilityItem {
         return maxDurability;
     }
 
     @Override
     public int getDurability() {
         return durability;
     }
 
+    @Override
+    public int getInitialDurability() {
+        return initialDurability;
+    }
+
     public boolean isBarHidden() {
         return barHidden;
     }
 
     /**
      * @return If both this is a VALID custom durability item and if the item is broken.
      *         This will return <code>false</code> if it is not a valid item
      */
diff --git a/MMOItems-API/src/main/java/net/Indyuce/mmoitems/api/interaction/util/DurabilityItem.java b/MMOItems-API/src/main/java/net/Indyuce/mmoitems/api/interaction/util/DurabilityItem.java
index c0bfb5733..0d994913b 100644
--- a/MMOItems-API/src/main/java/net/Indyuce/mmoitems/api/interaction/util/DurabilityItem.java
+++ b/MMOItems-API/src/main/java/net/Indyuce/mmoitems/api/interaction/util/DurabilityItem.java
@@ -91,16 +91,23 @@ public abstract class DurabilityItem {
         if (rollUnbreaking()) return this;
 
         // Apply durability decrease
         onDurabilityDecrease(loss);
 
         return this;
     }
 
+    /**
+     * 生成耐久度变化后的物品
+     *
+     * @return 更新后的物品，如果物品已损坏则返回 null
+     * @deprecated 使用 {@link #buildResult()} 替代，提供更丰富的结果信息
+     */
+    @Deprecated
     @Nullable
     public ItemStack toItem() {
 
         // Cache result
         if (itemOutput != null) return itemOutput;
 
         if (isBroken()) {
 
@@ -158,31 +165,130 @@ public abstract class DurabilityItem {
     protected abstract ItemStack applyChanges();
 
     public abstract boolean isBroken();
 
     public abstract int getDurability();
 
     public abstract int getMaxDurability();
 
+    /**
+     * 获取初始耐久度（创建此 DurabilityItem 实例时的耐久度值）
+     *
+     * @return 初始耐久度
+     */
+    public abstract int getInitialDurability();
+
     public abstract void onDurabilityAdd(int gain);
 
     public abstract void onDurabilityDecrease(int loss);
 
+    /**
+     * 构建耐久度操作结果
+     * <p>
+     * 此方法将当前耐久度状态转换为 {@link DurabilityResult}，调用方根据结果类型
+     * 决定如何处理物品（放回库存、移除、发送消息等）。
+     * </p>
+     * <p>
+     * <b>推荐使用此方法替代 {@link #toItem()} 和 {@link #updateInInventory()}</b>，
+     * 因为此方法提供更丰富的结果信息，避免静默失败。
+     * </p>
+     *
+     * @return 操作结果，包含新物品或损坏/降级状态
+     * @since 7.0
+     */
+    @NotNull
+    public DurabilityResult buildResult() {
+        final int initialDur = getInitialDurability();
+        final int currentDur = getDurability();
+
+        // 无变化
+        if (currentDur == initialDur) {
+            return new DurabilityResult.NoChange(nbtItem.getItem(), currentDur);
+        }
+
+        // 已损坏
+        if (isBroken()) {
+            // 损坏后丢失
+            if (isLostWhenBroken()) {
+                // 播放破碎音效
+                if (player != null) {
+                    if (item.getType().getMaxDurability() == 0) {
+                        player.getWorld().playSound(player.getLocation(), Sounds.ENTITY_ITEM_BREAK, 1, 1);
+                    }
+                    PlayerData.get(player).getInventory().watchVanillaSlot(
+                            io.lumine.mythic.lib.api.player.EquipmentSlot.fromBukkit(slot), Optional.empty());
+                }
+                return new DurabilityResult.Broken(initialDur);
+            }
+
+            // 检查降级修复
+            if (isDowngradedWhenBroken()) {
+                ItemTag uTag = ItemTag.getTagAtPath(ItemStats.UPGRADE.getNBTPath(), getNBTItem(), SupportedNBTTagValues.STRING);
+                if (uTag != null) {
+                    try {
+                        UpgradeData data = new UpgradeData(JsonParser.parseString((String) uTag.getValue()).getAsJsonObject());
+
+                        // 无法继续降级（已达最低等级）
+                        if (data.getLevel() <= data.getMin()) {
+                            return new DurabilityResult.Broken(initialDur);
+                        }
+
+                        // 降级并完全修复
+                        int previousLevel = data.getLevel();
+                        LiveMMOItem mmo = new LiveMMOItem(getNBTItem());
+                        mmo.getUpgradeTemplate().upgradeTo(mmo, previousLevel - 1);
+                        NBTItem downgradedNbt = mmo.newBuilder().buildNBT();
+
+                        // 完全修复降级后的物品
+                        DurabilityItem downgradedItem = DurabilityItem.from(player, downgradedNbt);
+                        Validate.notNull(downgradedItem, "Internal error");
+                        downgradedItem.addDurability(downgradedItem.getMaxDurability());
+                        ItemStack result = downgradedItem.toItem();
+                        Validate.notNull(result, "Internal error");
+
+                        return new DurabilityResult.Downgraded(result, previousLevel, previousLevel - 1);
+                    } catch (JsonSyntaxException | IllegalStateException ignored) {
+                        // 降级失败，视为损坏
+                    }
+                }
+            }
+
+            // 默认损坏处理
+            return new DurabilityResult.Broken(initialDur);
+        }
+
+        // 正常更新
+        ItemStack result = applyChanges();
+        return new DurabilityResult.Updated(result, initialDur, currentDur);
+    }
+
     public void updateInInventory(@NotNull PlayerItemDamageEvent event) {
         ItemStack resultingItem = toItem();
         if (resultingItem == null) event.setDamage(BIG_DAMAGE);
         else {
             event.setCancelled(true);
             updateInInventory();
         }
     }
 
     protected static final int BIG_DAMAGE = 1000000;
 
+    /**
+     * 将结果物品放回玩家库存
+     * <p>
+     * <b>警告：当 slot 为 null 时，此方法只更新 ItemMeta，不会更新 NBT 标签，
+     * 导致自定义耐久度修复失效！</b>
+     * </p>
+     *
+     * @return this
+     * @deprecated 使用 {@link #buildResult()} 获取结果，然后调用
+     * {@link DurabilityResult#applyToInventory(Player, EquipmentSlot)} 或手动更新库存
+     */
+    @Deprecated
     @NotNull
     public DurabilityItem updateInInventory() {
         ItemStack resultingItem = toItem();
 
         // No player is provided, just update the item and inshallah
         if (player == null || slot == null) {
             Validate.notNull(resultingItem, "Null item, no slot/player provided");
             this.item.setItemMeta(resultingItem.getItemMeta());
diff --git a/MMOItems-API/src/main/java/net/Indyuce/mmoitems/api/interaction/util/VanillaDurabilityItem.java b/MMOItems-API/src/main/java/net/Indyuce/mmoitems/api/interaction/util/VanillaDurabilityItem.java
index 4c3cc3f44..53812aef3 100644
--- a/MMOItems-API/src/main/java/net/Indyuce/mmoitems/api/interaction/util/VanillaDurabilityItem.java
+++ b/MMOItems-API/src/main/java/net/Indyuce/mmoitems/api/interaction/util/VanillaDurabilityItem.java
@@ -67,16 +67,21 @@ public class VanillaDurabilityItem extends DurabilityItem {
         return !nbtItem.getBoolean(ItemStats.WILL_BREAK.getNBTPath());
     }
 
     @Override
     public int getDurability() {
         return maxDamage - damage;
     }
 
+    @Override
+    public int getInitialDurability() {
+        return maxDamage - initialDamage;
+    }
+
     @Override
     public int getMaxDurability() {
         return maxDamage;
     }
 
     @Override
     public void onDurabilityAdd(int gain) {
         // TODO call event
diff --git a/MMOItems-API/src/main/java/net/Indyuce/mmoitems/command/mmoitems/item/RepairCommandTreeNode.java b/MMOItems-API/src/main/java/net/Indyuce/mmoitems/command/mmoitems/item/RepairCommandTreeNode.java
index 71976a0c1..11cc40013 100644
--- a/MMOItems-API/src/main/java/net/Indyuce/mmoitems/command/mmoitems/item/RepairCommandTreeNode.java
+++ b/MMOItems-API/src/main/java/net/Indyuce/mmoitems/command/mmoitems/item/RepairCommandTreeNode.java
@@ -1,18 +1,19 @@
 package net.Indyuce.mmoitems.command.mmoitems.item;
 
 import io.lumine.mythic.lib.command.CommandTreeExplorer;
 import io.lumine.mythic.lib.command.CommandTreeNode;
 import net.Indyuce.mmoitems.MMOItems;
-import net.Indyuce.mmoitems.api.interaction.util.DurabilityItem;
+import net.Indyuce.mmoitems.api.interaction.util.DurabilityUpdateHelper;
 import org.bukkit.ChatColor;
 import org.bukkit.Material;
 import org.bukkit.command.CommandSender;
 import org.bukkit.entity.Player;
+import org.bukkit.inventory.EquipmentSlot;
 import org.bukkit.inventory.ItemStack;
 import org.jetbrains.annotations.NotNull;
 
 public class RepairCommandTreeNode extends CommandTreeNode {
     public RepairCommandTreeNode(CommandTreeNode parent) {
         super(parent, "repair");
     }
 
@@ -20,26 +21,36 @@ public class RepairCommandTreeNode extends CommandTreeNode {
     public @NotNull CommandResult execute(CommandTreeExplorer explorer, CommandSender sender, String[] args) {
         if (!(sender instanceof Player)) {
             sender.sendMessage(ChatColor.RED + "This command is only for players.");
             return CommandResult.FAILURE;
         }
 
         Player player = (Player) sender;
 
-        // Mainhand priority
+        // Mainhand priority, track which slot the item is in
         ItemStack stack = player.getInventory().getItemInMainHand();
+        EquipmentSlot slot = EquipmentSlot.HAND;
+
         // Try offhand if mainhand is empty
-        if (stack == null || stack.getType() == Material.AIR) stack = player.getInventory().getItemInOffHand();
+        if (stack == null || stack.getType() == Material.AIR) {
+            stack = player.getInventory().getItemInOffHand();
+            slot = EquipmentSlot.OFF_HAND;
+        }
 
-        DurabilityItem durItem = DurabilityItem.from(player, stack);
-        if (durItem == null) {
+        // Use the new repair API
+        DurabilityUpdateHelper.RepairResult result = DurabilityUpdateHelper.repair(player, stack, Integer.MAX_VALUE);
+
+        if (result instanceof DurabilityUpdateHelper.RepairResult.Success) {
+            DurabilityUpdateHelper.RepairResult.Success success = (DurabilityUpdateHelper.RepairResult.Success) result;
+            // Apply the repaired item to the correct slot
+            player.getInventory().setItem(slot, success.item());
+            sender.sendMessage(MMOItems.plugin.getPrefix() + "Successfully repaired the item you are holding.");
+            return CommandResult.SUCCESS;
+        } else if (result instanceof DurabilityUpdateHelper.RepairResult.AlreadyFull) {
+            sender.sendMessage(MMOItems.plugin.getPrefix() + "The item is already at full durability.");
+            return CommandResult.SUCCESS;
+        } else {
             sender.sendMessage(MMOItems.plugin.getPrefix() + "The item you are holding can't be repaired.");
             return CommandResult.FAILURE;
         }
-
-        durItem.addDurability(durItem.getMaxDurability());
-        durItem.updateInInventory();
-
-        sender.sendMessage(MMOItems.plugin.getPrefix() + "Successfully repaired the item you are holding.");
-        return CommandResult.SUCCESS;
     }
 }
diff --git a/MMOItems-API/src/main/java/net/Indyuce/mmoitems/stat/RepairPower.java b/MMOItems-API/src/main/java/net/Indyuce/mmoitems/stat/RepairPower.java
index 5306f8ad1..c7f96db5a 100644
--- a/MMOItems-API/src/main/java/net/Indyuce/mmoitems/stat/RepairPower.java
+++ b/MMOItems-API/src/main/java/net/Indyuce/mmoitems/stat/RepairPower.java
@@ -2,27 +2,29 @@ package net.Indyuce.mmoitems.stat;
 
 import io.lumine.mythic.lib.api.item.NBTItem;
 import io.lumine.mythic.lib.version.Sounds;
 import net.Indyuce.mmoitems.ItemStats;
 import net.Indyuce.mmoitems.api.CustomSound;
 import net.Indyuce.mmoitems.api.Type;
 import net.Indyuce.mmoitems.api.interaction.Consumable;
 import net.Indyuce.mmoitems.api.interaction.util.DurabilityItem;
+import net.Indyuce.mmoitems.api.interaction.util.DurabilityResult;
 import net.Indyuce.mmoitems.api.player.PlayerData;
 import net.Indyuce.mmoitems.api.util.message.Message;
 import net.Indyuce.mmoitems.listener.CustomSoundListener;
 import net.Indyuce.mmoitems.stat.type.ConsumableItemInteraction;
 import net.Indyuce.mmoitems.stat.type.DoubleStat;
 import net.Indyuce.mmoitems.util.MMOUtils;
 import net.Indyuce.mmoitems.util.RepairUtils;
 import org.bukkit.ChatColor;
 import org.bukkit.Material;
 import org.bukkit.entity.Player;
 import org.bukkit.event.inventory.InventoryClickEvent;
+import org.bukkit.inventory.ItemStack;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
 import java.util.function.Function;
 
 public class RepairPower extends DoubleStat implements ConsumableItemInteraction {
     public RepairPower() {
         super("REPAIR", Material.ANVIL, "Repair Power", new String[]{"The flat amount of durability your item", "can repair when set an item."},
@@ -31,45 +33,91 @@ public class RepairPower extends DoubleStat implements ConsumableItemInteraction
 
     public static final String REPAIR_TYPE_TAG_KEY = "MMOITEMS_REPAIR_TYPE";
 
     @Override
     public boolean handleConsumableEffect(@NotNull InventoryClickEvent event, @NotNull PlayerData playerData, @NotNull Consumable consumable, @NotNull NBTItem target, Type targetType) {
         final int repairPower = (int) consumable.getNBTItem().getStat(ItemStats.REPAIR.getId());
         if (repairPower <= 0) return false;
 
-        return handleRepair(playerData, consumable, target, ignored -> repairPower);
+        RepairResult result = handleRepair(playerData, consumable, target, ignored -> repairPower);
+        if (result.success && result.repairedItem != null) {
+            // Use event.setCurrentItem() to correctly update the item in inventory
+            event.setCurrentItem(result.repairedItem);
+        }
+        return result.success;
+    }
+
+    /**
+     * 修复物品的结果封装
+     */
+    public static final class RepairResult {
+        public final boolean success;
+        @Nullable
+        public final ItemStack repairedItem;
+
+        private RepairResult(boolean success, @Nullable ItemStack repairedItem) {
+            this.success = success;
+            this.repairedItem = repairedItem;
+        }
+
+        public static RepairResult failed() {
+            return new RepairResult(false, null);
+        }
+
+        public static RepairResult success(@Nullable ItemStack item) {
+            return new RepairResult(true, item);
+        }
+
+        public static RepairResult vanillaSuccess() {
+            return new RepairResult(true, null);
+        }
     }
 
-    public static boolean handleRepair(@NotNull PlayerData playerData,
-                                       @NotNull Consumable consumable,
-                                       @NotNull NBTItem target,
-                                       @NotNull Function<DurabilityItem, Integer> repairAmountSupplier) {
+    /**
+     * 处理修复逻辑
+     *
+     * @return 修复结果，包含是否成功以及修复后的物品
+     */
+    @NotNull
+    public static RepairResult handleRepair(@NotNull PlayerData playerData,
+                                            @NotNull Consumable consumable,
+                                            @NotNull NBTItem target,
+                                            @NotNull Function<DurabilityItem, Integer> repairAmountSupplier) {
 
         // Check repair reference
         final Player player = playerData.getPlayer();
         final @Nullable String repairType1 = consumable.getNBTItem().getString(REPAIR_TYPE_TAG_KEY);
         final @Nullable String repairType2 = target.getString(REPAIR_TYPE_TAG_KEY);
         if (!MMOUtils.checkReference(repairType1, repairType2)) {
             Message.UNABLE_TO_REPAIR.format(ChatColor.RED, "#item#", MMOUtils.getDisplayName(target.getItem())).send(player);
             player.getPlayer().playSound(player.getPlayer().getLocation(), Sounds.ENTITY_VILLAGER_NO, 1, 1.5f);
-            return false;
+            return RepairResult.failed();
         }
 
         // Custom durability
         final DurabilityItem durItem = DurabilityItem.from(player, target);
         if (durItem != null) {
-            if (durItem.getDurability() >= durItem.getMaxDurability()) return false;
+            if (durItem.getDurability() >= durItem.getMaxDurability()) return RepairResult.failed();
 
             final int repairPower = repairAmountSupplier.apply(durItem);
             durItem.addDurability(repairPower);
-            durItem.updateInInventory();
-            Message.REPAIRED_ITEM
-                    .format(ChatColor.YELLOW, "#item#", MMOUtils.getDisplayName(target.getItem()), "#amount#", String.valueOf(repairPower))
-                    .send(player);
-            CustomSoundListener.playSound(consumable.getItem(), CustomSound.ON_CONSUME, player);
-            return true;
+
+            // Use the new buildResult() API to get the repaired item
+            DurabilityResult result = durItem.buildResult();
+            ItemStack repairedItem = result.getItem();
+
+            if (repairedItem != null) {
+                Message.REPAIRED_ITEM
+                        .format(ChatColor.YELLOW, "#item#", MMOUtils.getDisplayName(target.getItem()), "#amount#", String.valueOf(repairPower))
+                        .send(player);
+                CustomSoundListener.playSound(consumable.getItem(), CustomSound.ON_CONSUME, player);
+                return RepairResult.success(repairedItem);
+            }
+
+            return RepairResult.failed();
         }
 
         // vanilla durability
-        return RepairUtils.repairVanillaItem(playerData, target, consumable, repairAmountSupplier.apply(null));
+        boolean vanillaResult = RepairUtils.repairVanillaItem(playerData, target, consumable, repairAmountSupplier.apply(null));
+        return vanillaResult ? RepairResult.vanillaSuccess() : RepairResult.failed();
     }
 }
diff --git a/MMOItems-API/src/main/java/net/Indyuce/mmoitems/stat/RepairPowerPercent.java b/MMOItems-API/src/main/java/net/Indyuce/mmoitems/stat/RepairPowerPercent.java
index 759d13751..82ec4d9b5 100644
--- a/MMOItems-API/src/main/java/net/Indyuce/mmoitems/stat/RepairPowerPercent.java
+++ b/MMOItems-API/src/main/java/net/Indyuce/mmoitems/stat/RepairPowerPercent.java
@@ -21,14 +21,22 @@ public class RepairPowerPercent extends DoubleStat implements ConsumableItemInte
 
 
     @Override
     public boolean handleConsumableEffect(@NotNull InventoryClickEvent event, @NotNull PlayerData playerData, @NotNull Consumable consumable, @NotNull NBTItem target, @Nullable Type targetType) {
         final double repairPower = consumable.getNBTItem().getStat(ItemStats.REPAIR_PERCENT.getId());
         if (repairPower <= 0)
             return false;
 
-        return RepairPower.handleRepair(playerData, consumable, target, durItem -> {
+        RepairPower.RepairResult result = RepairPower.handleRepair(playerData, consumable, target, durItem -> {
+            // durItem can be null for vanilla items, use a default value
+            if (durItem == null) return 0;
             final double maxDurability = durItem.getMaxDurability();
             return (int) (repairPower * maxDurability / 100);
         });
+
+        // Use event.setCurrentItem() to correctly update the item in inventory
+        if (result.success && result.repairedItem != null) {
+            event.setCurrentItem(result.repairedItem);
+        }
+        return result.success;
     }
 }
diff --git a/MMOItems-Dist/src/main/java/net/Indyuce/mmoitems/listener/DurabilityListener.java b/MMOItems-Dist/src/main/java/net/Indyuce/mmoitems/listener/DurabilityListener.java
index 7750323d6..3c0b4b8fd 100644
--- a/MMOItems-Dist/src/main/java/net/Indyuce/mmoitems/listener/DurabilityListener.java
+++ b/MMOItems-Dist/src/main/java/net/Indyuce/mmoitems/listener/DurabilityListener.java
@@ -1,16 +1,17 @@
 package net.Indyuce.mmoitems.listener;
 
 import io.lumine.mythic.lib.UtilityMethods;
 import io.lumine.mythic.lib.api.event.PlayerAttackEvent;
 import io.lumine.mythic.lib.damage.DamageType;
 import io.lumine.mythic.lib.version.Sounds;
 import net.Indyuce.mmoitems.MMOItems;
 import net.Indyuce.mmoitems.api.interaction.util.DurabilityItem;
+import net.Indyuce.mmoitems.api.interaction.util.DurabilityResult;
 import org.bukkit.Material;
 import org.bukkit.entity.EntityType;
 import org.bukkit.entity.LivingEntity;
 import org.bukkit.entity.Player;
 import org.bukkit.event.EventHandler;
 import org.bukkit.event.EventPriority;
 import org.bukkit.event.Listener;
 import org.bukkit.event.entity.EntityDamageByEntityEvent;
@@ -34,17 +35,17 @@ public class DurabilityListener implements Listener {
     public void itemDamage(PlayerItemDamageEvent event) {
         final DurabilityItem item = DurabilityItem.from(event.getPlayer(), event.getItem());
         if (item == null) return;
 
         // Cap durability loss
         event.setDamage(capDurabilityLoss(event.getDamage()));
 
         item.onDurabilityDecrease(event.getDamage()); // Calculate item durability loss
-        item.updateInInventory(event); // Update item
+        item.updateInInventory(event); // Update item - this overload is fine, it uses event.setDamage()
     }
 
     private static final List<DamageCause> IGNORED_CAUSES = Arrays.asList(DamageCause.DROWNING, DamageCause.SUICIDE, DamageCause.FALL, DamageCause.VOID,
             DamageCause.FIRE_TICK, DamageCause.SUFFOCATION, DamageCause.POISON, DamageCause.WITHER, DamageCause.STARVATION, DamageCause.MAGIC, DamageCause.KILL);
     private static final EquipmentSlot[] ARMOR_SLOTS = {EquipmentSlot.HEAD, EquipmentSlot.CHEST, EquipmentSlot.LEGS, EquipmentSlot.FEET};
 
     /**
      * Handles durability loss for NON-DAMAGEABLE items, CUSTOM durability.
@@ -107,54 +108,73 @@ public class DurabilityListener implements Listener {
     public void handleMmoDamageDurability(PlayerAttackEvent event) {
         if (!MMOItems.plugin.getLanguage().durabilityLossOnMmoDamage) return;
 
         final Set<DamageType> types = event.getAttack().getDamage().collectTypes();
         if (types.contains(DamageType.WEAPON) || types.contains(DamageType.PROJECTILE) || types.contains(DamageType.UNARMED))
             return;
 
         final Player player = event.getAttacker().getPlayer();
-        final DurabilityItem durabilityItem = DurabilityItem.custom(player, EquipmentSlot.HAND, player.getInventory().getItemInMainHand());
+        final EquipmentSlot slot = EquipmentSlot.HAND;
+        final DurabilityItem durabilityItem = DurabilityItem.custom(player, slot, player.getInventory().getItemInMainHand());
         if (durabilityItem == null) return;
 
         durabilityItem.decreaseDurability(capDurabilityLoss(1));
-        if (durabilityItem.updateInInventory().toItem() == null) {
+
+        // Use new buildResult() API to get the result and apply it correctly
+        DurabilityResult result = durabilityItem.buildResult();
+        if (result.isBroken()) {
+            player.getInventory().setItem(slot, null);
             player.getWorld().playSound(player.getLocation(), Sounds.ENTITY_ITEM_BREAK, 1, 1);
+        } else {
+            result.applyToInventory(player, slot);
         }
     }
 
     /**
      * Handles mending exp for DAMAGEABLE items, CUSTOM durability.
      */
     @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
     public void mendEvent(PlayerItemMendEvent event) {
 
         // Useless repair amount
         if (event.getRepairAmount() <= 0) return;
 
-        DurabilityItem durItem = DurabilityItem.custom(null, event.getItem());
+        // Get the player and slot from the event
+        final Player player = event.getPlayer();
+        final EquipmentSlot slot = event.getSlot();
+
+        // Use the slot from the event to properly update the item
+        DurabilityItem durItem = DurabilityItem.custom(player, slot, event.getItem());
         if (durItem != null) {
             event.setCancelled(true); // Cancel event
             durItem.addDurability(event.getRepairAmount()); // Mend
-            durItem.updateInInventory(); // Update inventory
+
+            // Use new buildResult() API to properly update the item
+            DurabilityResult result = durItem.buildResult();
+            result.applyToInventory(player, slot);
         }
     }
 
     /**
      * This method is for all the items which have 0 max durability, which
      * are not breakable, hence the call to {@link Material#getMaxDurability()}
      */
     private void handleUndamageableItem(Player player, @Nullable ItemStack stack, EquipmentSlot slot, int damage) {
         if (UtilityMethods.isAir(stack) || stack.getType().getMaxDurability() > 0) return;
 
         final DurabilityItem item = DurabilityItem.custom(player, slot, stack);
         if (item == null) return;
 
         damage = capDurabilityLoss(damage); // Cap durability loss
         item.decreaseDurability(damage);
 
-        if (item.updateInInventory().toItem() == null) {
+        // Use new buildResult() API to get the result and apply it correctly
+        DurabilityResult result = item.buildResult();
+        if (result.isBroken()) {
+            player.getInventory().setItem(slot, null);
             // Play break sound
             player.getWorld().playSound(player.getLocation(), Sounds.ENTITY_ITEM_BREAK, 1, 1);
+        } else {
+            result.applyToInventory(player, slot);
         }
-
     }
 }
