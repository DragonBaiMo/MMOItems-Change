# 变更摘要：重构耐久度系统，引入 `DurabilityResult` 替代副作用方法，修复了 NBT 更新丢失的隐患。

## 文件：MMOItems-API/src/main/java/net/Indyuce/mmoitems/api/interaction/util/DurabilityItem.java
### L155：[HIGH] 忽略配置导致物品误删
`buildResult()` 在物品损坏（`isBroken()` 为真）且未触发降级时，无条件返回 `DurabilityResult.Broken`。
在 `DurabilityListener.java` 中，`result.isBroken()` 会导致直接将物品设为 `null`（删除）。
这意味着即使物品配置了 **"损坏时不消失"** (`isLostWhenBroken() == false`)，也会被强制删除。

旧逻辑中，如果 `isLostWhenBroken()` 为 `false`，`toItem()` 会返回损坏后的物品对象，而不会返回 `null`。

**修复建议**：
当 `isLostWhenBroken()` 为 `false` 时，应返回 `DurabilityResult.Updated`，包含损坏后的物品状态，以保持物品在玩家背包中。

```diff
            // 检查降级修复
            if (isDowngradedWhenBroken()) {
                // ... (略) ...
            }
 
-           // 默认损坏处理
-           return new DurabilityResult.Broken(initialDur);
+           // 默认损坏处理：如果配置了损坏不丢失，则作为更新返回（保留物品）
+           if (!isLostWhenBroken()) {
+               return new DurabilityResult.Updated(applyChanges(), initialDur, getDurability());
+           }
+
+           return new DurabilityResult.Broken(initialDur);
        }
 
        // 正常更新
```

## 文件：MMOItems-API/src/main/java/net/Indyuce/mmoitems/api/interaction/util/DurabilityItem.java
### L245：[MEDIUM] 潜在的运行时异常
```java
DurabilityItem downgradedItem = DurabilityItem.from(player, downgradedNbt);
Validate.notNull(downgradedItem, "Internal error");
```
`Validate.notNull` 会抛出 `IllegalArgumentException`，而外层只捕获了 `JsonSyntaxException | IllegalStateException`。
如果因某种原因（如 NBT 数据异常）导致 `downgradedItem` 创建失败（返回 null），这会抛出未捕获异常，可能导致事件处理中断。建议改为捕获所有异常或在该分支内安全处理 null 情况（视为降级失败）。

## 文件：MMOItems-API/src/main/java/net/Indyuce/mmoitems/command/mmoitems/item/RepairCommandTreeNode.java
### L38：[LOW] 建议使用常量
`EquipmentSlot.HAND` 应为 `EquipmentSlot.HAND` (Bukkit API)。虽然逻辑正确，但确保引用的 `EquipmentSlot` 是 Bukkit 的枚举。代码中看起来是正确的，只需确认导入。
(注：diff 中显示 `import org.bukkit.inventory.EquipmentSlot;`，此处无问题，pass)

## 业务逻辑变更确认（无缺陷）
以下变更属于合理的重构，未发现缺陷：
1. **API 行为变更**：`RepairPower` 现在在物品满耐久时返回 `failed`，避免了消耗品被浪费。
2. **废弃方法**：`toItem()` 和无参 `updateInInventory()` 被废弃，所有关键调用点（Listener, Command）均已迁移至新的 `buildResult()` 模式。