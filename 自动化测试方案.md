你这个痛点本质上是：人类肉眼点 GUI 点到手麻，AI 写 Bug 写到起飞，但缺一个“能自动点按钮、还能自动验收效果”的裁判。用 MockBukkit 先把大部分“服务端 GUI + 监听器 + 消息/效果”锁死，是目前性价比最高的路线之一。它就是在测试里启动一个假的服务器环境，让你用代码模拟玩家、背包、点击、事件触发，然后做断言。([GitHub][1])

下面按你要的两件事来：① Maven/配置怎么接；② 给你一套专门写 Minecraft 自动化测试的提示词脚本，让 AI 按流程产出并跑测试。

---

一、MockBukkit 的依赖配置（Maven / Gradle）

关键点就两个：
1）选对 artifact（按 MC 大版本分，例如 mockbukkit-v1.21）。([docs.mockbukkit.org][2])
2）版本别瞎写，去仓库挑最新稳定（版本更新很勤快）。([Maven Repository][3])

1. Maven（pom.xml）示例

```xml
<dependencies>
  <!-- JUnit 5（用 BOM 管版本，省得你到处抄版本号） -->
  <dependency>
    <groupId>org.junit</groupId>
    <artifactId>junit-bom</artifactId>
    <version>5.14.2</version>
    <type>pom</type>
    <scope>import</scope>
  </dependency>

  <dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter</artifactId>
    <scope>test</scope>
  </dependency>

  <!-- MockBukkit（按你的目标 MC 版本选 mockbukkit-v1.xx） -->
  <dependency>
    <groupId>org.mockbukkit.mockbukkit</groupId>
    <artifactId>mockbukkit-v1.21</artifactId>
    <version>4.0.0</version>
    <scope>test</scope>
  </dependency>
</dependencies>

<build>
  <plugins>
    <!-- 让 Maven 跑 JUnit 5 -->
    <plugin>
      <groupId>org.apache.maven.plugins</groupId>
      <artifactId>maven-surefire-plugin</artifactId>
      <version>3.5.2</version>
      <configuration>
        <useModulePath>false</useModulePath>
      </configuration>
    </plugin>
  </plugins>
</build>
```

MockBukkit 的 Maven 坐标（groupId/artifactId）长这样：Apache Maven 里加 `org.mockbukkit.mockbukkit:mockbukkit-v1.21`。([docs.mockbukkit.org][2])

2. Gradle（build.gradle）示例

```gradle
dependencies {
  testImplementation(platform("org.junit:junit-bom:5.14.2"))
  testImplementation("org.junit.jupiter:junit-jupiter")

  testImplementation("org.mockbukkit.mockbukkit:mockbukkit-v1.21:4.0.0")
}

test {
  useJUnitPlatform()
}
```

（你要是用 Gradle Kotlin DSL，语法换成 `testImplementation(...)` 那套就行。）

---

二、MockBukkit 基本用法：怎么“模拟 GUI + 监听器 + 断言效果”

1. 最小测试骨架（启动/关闭 mock server）

官方范式就是：`MockBukkit.mock()` -> 测完 `MockBukkit.unmock()`。([docs.mockbukkit.org][4])

```java
import org.bukkit.plugin.java.JavaPlugin;
import org.junit.jupiter.api.*;
import org.mockbukkit.mockbukkit.MockBukkit;
import org.mockbukkit.mockbukkit.ServerMock;

class MyPluginTest {
  private ServerMock server;
  private JavaPlugin plugin;

  @BeforeEach
  void setUp() {
    server = MockBukkit.mock();
    plugin = MockBukkit.load(MyPlugin.class);
  }

  @AfterEach
  void tearDown() {
    MockBukkit.unmock();
  }

  @Test
  void sanity() {
    Assertions.assertNotNull(plugin);
  }
}
```

2. GUI 多的项目，断言别只盯“界面长啥样”

Minecraft 的 GUI（Inventory）对你这种插件来说，本质是：

* 打开了哪个 Inventory（标题/类型/槽位内容）
* 玩家点了哪个槽（ClickType / slot）
* 你的监听器有没有拦截、改物品、发消息、播音效、触发别的事件、安排任务

MockBukkit 给你的断言抓手主要在这几类：

A. 断言“发了什么消息”
只要对象实现了 MessageTarget（玩家/实体/控制台之类），就能 `assertSaid(...)`、`assertNoMoreSaid()`。([docs.mockbukkit.org][5])

B. 断言“某个事件有没有被触发”，甚至用 predicate 验证事件字段
`PluginManagerMock.assertEventFired(EventClass, predicate)` 这种就是为“监听器链路”准备的。([docs.mockbukkit.org][6])

C. 断言“玩家在 GUI 里点了啥”，以及用模拟点击触发你的监听器逻辑
MockBukkit 的 PlayerMock 有 `simulateInventoryClick(...)`（有不同参数形态）。([Javadoc.io][7])
另外它也提供了 InventoryViewMock 等相关 mock 组件，专门服务于 Inventory/GUI 测试链路。([Javadoc.io][8])

3. 一个“GUI 点击 -> 监听器 -> 断言效果”的完整示例（模板）

下面这个例子表达的是套路，不绑定你的具体业务：打开菜单 -> 点按钮 -> 监听器取消点击并发消息 -> 断言消息与事件都符合预期。

```java
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.Inventory;
import org.junit.jupiter.api.*;
import org.mockbukkit.mockbukkit.MockBukkit;
import org.mockbukkit.mockbukkit.ServerMock;
import org.mockbukkit.mockbukkit.entity.PlayerMock;
import org.mockbukkit.mockbukkit.plugin.PluginManagerMock;

class MenuFlowTest {
  private ServerMock server;
  private MyPlugin plugin;

  @BeforeEach
  void setUp() {
    server = MockBukkit.mock();
    plugin = MockBukkit.load(MyPlugin.class);
  }

  @AfterEach
  void tearDown() {
    MockBukkit.unmock();
  }

  @Test
  void click_button_should_send_message_and_cancel() {
    PlayerMock p = server.addPlayer();
    PluginManagerMock pm = server.getPluginManager();

    // 1) 让你的代码打开 GUI（你项目里通常会有 openMenu(player)）
    plugin.getMenuService().openMainMenu(p);

    // 2) 模拟玩家点击某个槽位（例如 slot=13 是“开始/确认”按钮）
    p.simulateInventoryClick(13);

    // 3) 断言：消息、事件、是否取消 等
    p.assertSaid("已确认");       // MessageTarget 断言 :contentReference[oaicite:12]{index=12}
    p.assertNoMoreSaid();

    pm.assertEventFired(InventoryClickEvent.class, e -> e.isCancelled()); // 事件断言 :contentReference[oaicite:13]{index=13}
  }
}
```

你会发现：这套断言不需要“看见 GUI”，也不需要真客户端，照样能把“点了什么按钮 -> 发生了什么后果”钉死。人类最擅长的事情是把眼睛当测试框架用，偏偏这事最不可靠。

---

三、给 AI 的“Minecraft 自动化测试 Prompt 脚本”（专门面向 GUI + 监听器 + 效果观测）

你要的不是“让 AI 写一堆看起来像测试的东西”，而是让它按工程化流程做事：先复现 bug（写失败测试）-> 再修 -> 再保证回归。下面这套直接可丢进你的 Agent 里用。

1. System Prompt（测试工程师角色）

```text
你是 Minecraft（Bukkit/Paper）插件的“自动化测试工程师”，目标是把用户描述的 GUI/监听器 Bug 变成可重复、可回归的自动化测试，并确保能在本地与 CI 中稳定运行。

技术栈固定：
- JUnit 5
- MockBukkit（按目标 MC 版本选择 mockbukkit-v1.xx）
- 构建工具：优先适配用户项目现有的 Maven 或 Gradle

强制工作流（不得跳步）：
1. 读取用户提供的：Bug 复现步骤、期望行为、相关类/监听器/菜单代码位置（或最小代码片段）。
2. 先写“失败测试”(red)：用 MockBukkit 启动 ServerMock，加载插件，创建 PlayerMock，走完整 GUI/事件链路，断言应当成立但现在失败的结果。
3. 运行测试（通过命令行）：Maven 用 mvn test；Gradle 用 gradle test。若失败信息与预期不一致，调整测试直到它精准复现该 bug。
4. 再写修复建议或补丁（green），并补充/调整测试覆盖边界情况。
5. 输出最终交付：新增/修改的测试文件列表、关键断言点、运行命令、CI 建议。

断言策略必须覆盖（按 bug 选择其一或多项）：
- GUI：Inventory/InventoryView 的标题、类型、槽位 ItemStack（material/meta/pdc 等）
- 监听器链路：PluginManagerMock.assertEventFired(事件类型, predicate)
- 用户可见反馈：MessageTarget.assertSaid / assertNoMoreSaid（含顺序）
- 其他效果：音效/标题/actionbar/调度任务（若项目用到）

禁止行为：
- 不得凭空捏造 Bukkit API 或 MockBukkit API；遇到不确定 API，必须以“项目现有依赖 + MockBukkit 文档/代码”对齐。
- 不得只写“看起来覆盖了”的测试，必须能稳定复现 bug（先红后绿）。
```

2. User Prompt 模板（你每次把 bug 丢给 AI 就按这个填）

```text
项目构建工具：Maven 或 Gradle（填一个）
目标 MC 版本：1.xx（用于选择 mockbukkit-v1.xx）
插件入口类：xxx.yyy.MyPlugin（JavaPlugin 子类全限定名）

Bug 复现步骤（要像脚本一样可执行）：
1) 玩家执行命令 / 触发动作：...
2) 打开 GUI：标题/类型/大小：...
3) 点击槽位：slot=__，clickType=__，期望按钮语义：...
4) 预期结果（必须可观测）：应发送消息/应取消事件/应更换物品/应扣费/应切页/应关闭菜单/应触发某事件：...
5) 当前实际结果：...

相关代码位置（至少给类名或文件路径）：
- 打开 GUI 的入口：...
- InventoryClickEvent / 相关监听器：...
- 业务处理方法：...

请你交付：
A) 能稳定复现 bug 的失败测试（JUnit5 + MockBukkit）
B) 建议的修复点（若能给 patch 更好）
C) 回归测试覆盖（至少 1 个边界用例）
D) 运行命令（mvn test / gradle test）
```

---

四、顺手把“自动去跑”这件事变成常态（CI）

你只要把测试接进 GitHub Actions，以后 AI 写完代码跑不过测试就直接社死在 CI 上，不用你手动点 GUI 复检。思路就是：装 JDK -> 跑 `mvn test` 或 `gradle test`。实现细节看你仓库结构，原理就这么朴素。

---

你现在选用 MockBukkit 的方向是对的：它不是帮你“渲染 GUI”，它是帮你把“玩家点按钮后的服务端后果”写成可执行断言，从此把人工测试从主流程里踢出去。只要你把 bug 用上面那个模板描述清楚，AI 产出的测试就能精准把它钉在地上，跑一次就知道有没有复发。